#!/bin/bash

# Global Configuration (can be modified or passed as arguments)
OUTPUT_DIR="oc-mirror-output"
CSV_FILE="trivy_vulnerabilities.csv"

# Function to display usage information
display_usage() {
    echo "Usage: $0 <openshift_operator_index_version>"
    echo "Example: $0 v4.17"
    echo "This script mirrors a specified OpenShift operator index, scans its images with Trivy for High/Critical vulnerabilities,"
    echo "and outputs the results to a CSV file."
}

# Function to validate prerequisites (oc and trivy commands)
validate_prerequisites() {
    echo "--- Validating prerequisites ---"
    if ! command -v oc &> /dev/null; then
        echo "Error: 'oc' command not found. Please install OpenShift CLI."
        return 1
    fi

    if ! command -v trivy &> /dev/null; then
        echo "Error: 'trivy' command not found. Please install Trivy."
        return 1
    fi
    echo "Prerequisites met."
    return 0
}

# Function to perform the oc mirror operation
# Arguments: $1 = OPERATOR_INDEX, $2 = OUTPUT_DIR
do_oc_mirror() {
    local operator_index="$1"
    local output_dir="$2"

    echo "--- Running oc mirror for $operator_index ---"
    mkdir -p "$output_dir" || { echo "Error: Could not create output directory '$output_dir'."; return 1; }

    # Using --force to overwrite existing files, can be removed if not desired
    oc mirror --from "$operator_index" --to-dir "$output_dir" --force
    if [ $? -ne 0 ]; then
        echo "Error: 'oc mirror' command failed for $operator_index. Exiting."
        return 1
    fi

    echo "--- oc mirror completed. Files downloaded to $output_dir ---"
    return 0
}

# Function to find the image list file generated by oc mirror
# Arguments: $1 = OUTPUT_DIR
# Returns: Path to the image list file, or empty if not found
find_image_list_file() {
    local output_dir="$1"
    local image_list_file

    # Common names for the image list file generated by oc mirror
    image_list_file=$(find "$output_dir" -name "release-images-*.txt" -o -name "images.txt" -o -name "image-references.txt" | head -n 1)

    if [ -z "$image_list_file" ]; then
        echo "Error: Could not find a reliable list of mirrored images (e.g., release-images-*.txt) in '$output_dir'." >&2
        return 1 # Indicate failure
    fi

    echo "$image_list_file" # Return the path
    return 0
}

# Function to scan a single image with Trivy and process its output
# Arguments: $1 = IMAGE_REF, $2 = REGISTRY, $3 = PACKAGE, $4 = IMAGE_HASH, $5 = IMAGE_VERSION, $6 = CSV_FILE
scan_image_with_trivy() {
    local image_ref="$1"
    local registry="$2"
    local package="$3"
    local image_hash="$4"
    local image_version="$5"
    local csv_file="$6"

    echo "Scanning image: $image_ref"

    # Run Trivy scan for High/Critical vulnerabilities
    # For a fully offline scenario, Trivy needs to be able to access the mirrored content.
    # This typically means setting up a local registry that oc mirror populated,
    # or extracting images to tarballs and scanning them.
    # For now, this assumes Trivy can resolve and pull the image if necessary, or that
    # the image_ref points to content Trivy can directly access (e.g., an OCI layout if configured).
    # If this is for a true air-gapped environment after `oc mirror`, this Trivy command
    # might fail unless network is routed to an internal mirror, or images are pre-pulled by Trivy.
    TRIVY_SCAN_OUTPUT=$(trivy image --severity HIGH,CRITICAL --format json "$image_ref" 2>/dev/null)

    # Check if Trivy output is empty or contains no vulnerabilities
    if [ -z "$TRIVY_SCAN_OUTPUT" ] || [ "$TRIVY_SCAN_OUTPUT" == "[]" ]; then
        echo "No HIGH or CRITICAL vulnerabilities found for $image_ref or scan failed."
        echo "\"$registry\",\"$package\",\"$image_hash\",\"$image_version\"" >> "$csv_file"
        return 0 # Success, no relevant vulnerabilities found
    fi

    # Parse Trivy output for High+Critical vulnerabilities
    # Check if there are any vulnerabilities found in the JSON output
    VULN_COUNT=$(echo "$TRIVY_SCAN_OUTPUT" | jq -r '.[].Vulnerabilities | length')

    if [ "$VULN_COUNT" -gt 0 ]; then
        # If vulnerabilities are found, extract details and append to CSV
        echo "$TRIVY_SCAN_OUTPUT" | jq -r '
            .[] |
            select(.Vulnerabilities | length > 0) |
            .Vulnerabilities[] |
            select(.Severity == "HIGH" or .Severity == "CRITICAL") |
            "\"'$registry'\",\"'$package'\",\"'$image_hash'\",\"'$image_version'\""
        ' >> "$csv_file"
    else
        echo "No HIGH or CRITICAL vulnerabilities found for $image_ref."
        # Add a row to the CSV even if no vulnerabilities were found for that image
        echo "\"$registry\",\"$package\",\"$image_hash\",\"$image_version\"" >> "$csv_file"
    fi

    return 0
}

# Main function to orchestrate the process
main() {
    local operator_version="$1"

    # Input validation
    if [ -z "$operator_version" ]; then
        display_usage
        exit 1
    fi

    local operator_index="registry.redhat.io/redhat/redhat-operator-index:$operator_version"

    # Validate prerequisites
    validate_prerequisites || exit 1

    # Perform oc mirror
    do_oc_mirror "$operator_index" "$OUTPUT_DIR" || exit 1

    # Initialize CSV file with headers
    echo "Registry,Package,Image,Version" > "$CSV_FILE"
    echo "--- Scanning images with Trivy ---"

    # Find the list of mirrored images
    local image_list_file
    image_list_file=$(find_image_list_file "$OUTPUT_DIR")
    if [ $? -ne 0 ]; then # Check the return status of the function call
        exit 1
    fi
    echo "--- Processing images from $image_list_file ---"

    # Iterate over each image found in the list file
    grep -E "registry.redhat.io/.+/.+@sha256:" "$image_list_file" | while IFS= read -r image_ref; do
        # Extract Registry, Package, and Image Hash from the full image reference
        # Format: <registry>/<pkg>@<image_hash>
        local registry=$(echo "$image_ref" | awk -F'/' '{print $1}')
        local package=$(echo "$image_ref" | sed -E 's|[^/]+/(.*)@.*|\1|') # e.g., openshift4/ose-oauth-proxy
        local image_hash=$(echo "$image_ref" | awk -F'@' '{print $2}')

        # Use the provided operator version for the 'Version' column
        local image_version="$operator_version"

        scan_image_with_trivy "$image_ref" "$registry" "$package" "$image_hash" "$image_version" "$CSV_FILE"
        # No need to exit on individual scan failures, continue processing other images
    done

    echo "--- Trivy scanning completed. Results saved to $CSV_FILE ---"
    echo "You can now open '$CSV_FILE' to view the results."
}

# Call the main function with command-line arguments
main "$@"